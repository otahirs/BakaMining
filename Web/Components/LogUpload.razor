@using System.IO
@using BakaMining.Utils
@using ProcessM.NET.Import
@using ProcessM.NET.Model
@using ProcessM.NET.Model.DataAnalysis
@using Transition = ProcessM.NET.Model.BasicPetriNet.Transition
@inject Services.Storage.EventLogStore EventLogStore
@inject IDialogService DialogService


<MudAlert Severity="Severity.Warning" Class="mb-4">Not suitable for large logs - thousands of lines - they take very long time to process.</MudAlert>
<MudAlert Severity="Severity.Info" Class="my-4">Import expects .csv file with one header row, separator <code>{';', ',', '|', '\t', ','}</code> detected automaticaly.</MudAlert>
<InputFile id="fileInput" OnChange="OnFileSelected" hidden accept=".csv"/>

<MudButton HtmlTag="label"
           Variant="Variant.Filled"
           Color="Color.Primary"
           StartIcon="@Icons.Material.Outlined.FileUpload"
           for="fileInput"
           Class="my-4">
    Import .csv
</MudButton>


@code {

    [Parameter]
    public EventCallback OnLogUploaded { get; set; }
    
    ImportedEventLog _importedLog;
    IBrowserFile _file;

    private async void OnFileSelected(InputFileChangeEventArgs e)
    {
        foreach (var f in e.GetMultipleFiles())
        {
            _file = f;
            await using var memoryString = new MemoryStream();
            await _file.OpenReadStream(1000000000).CopyToAsync(memoryString);
            memoryString.Seek(0, SeekOrigin.Begin);
            _importedLog = CSVImport.MakeDataFrame(memoryString);
        }
        await DialogService.Show<DialogLogProperties>(
            "Set Activity & CaseId", 
            new DialogParameters { ["Log"]=_importedLog },
            new DialogOptions { DisableBackdropClick = true }
            ).Result;
        UploadLog();
    }

    private async void UploadLog()
    {
        var workflowLog = new WorkflowLog(_importedLog);

        var logFile = new EventLogFile()
        {
            Metadata = new FileMetadata()
            {
                Name = _file.Name,
                Modified = _file.LastModified,
                Size =  _file.Size
            },
            EventLog = OrderByActivityFrequency(workflowLog)
        };
        await EventLogStore.Add(logFile);
        await OnLogUploaded.InvokeAsync();
    }

    private WorkflowLog OrderByActivityFrequency(WorkflowLog wfLog)
    {
        var comparer = new ActivitiesComparer();
        return new WorkflowLog(wfLog.WorkflowTraces
            .GroupBy(tr => tr.Activities, comparer)
            .OrderByDescending(gr => gr.Count())
            .SelectMany(gr => gr)
            .ToList());
    }
}