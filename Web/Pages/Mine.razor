@page "/Mine"
@page "/Mine/{Key}"
@inject Services.Storage.EventLogStore EventLogStore
@inject Services.Storage.PetriNetStore PetriNetStore
@using ProcessM.NET.Discovery.HeuristicMiner
@using ProcessM.NET.Discovery.Alpha
@using ProcessM.NET.Export
@using ProcessM.NET.Model.BasicPetriNet
@using ProcessM.NET.Model.DataAnalysis
@using Blazor.DownloadFileFast.Interfaces
@using ProcessM.NET.Model.GraphvizNet
@inject IBlazorDownloadFileService DownloadFileService

@if (string.IsNullOrEmpty(Key))
{
    <MudAlert Severity="Severity.Info">Go to <MudLink Href="/">Logs</MudLink> to select a file to mine.</MudAlert>
    return;
}
<MudGrid>
    <MudItem xs="12">
        
    </MudItem>
    <MudItem xs="10" Style="background-color: white; height: 80vh">
        <MudPaper Elevation="0" Style="height: 100%">
            <Graph 
                @ref="_graph" 
                OnTransitionColorChanged="TransitionColorChanged" 
                OnTransitionVisibilityChanged="TransitionVisibilityChanged"
                OnRenderingFinished="RemoveOverlay" />
        </MudPaper>
    </MudItem>
    <MudItem xs="2">
        <MudCard Elevation="3">
            <MudCardContent>
                <EditForm Model="@_minerSettings" OnValidSubmit="OnValidSubmit">
                    <DataAnnotationsValidator/>
                    <MudText Typo="Typo.h3">Miner</MudText>
                    <MudSelect T="Miner" Label="Miner implementation" AnchorOrigin="Origin.BottomCenter" @bind-Value=@_selectedMiner Class="mb-4">
                        @foreach (var m in Enum.GetValues<Miner>())
                        {
                            <MudSelectItem Value="@(m)"/>
                        }
                    </MudSelect>
                    @if (_selectedMiner == Miner.Alpha)
                    {
                        <MudAlert Severity="Severity.Warning" Class="mb-4">Alpha miner implementation slows down exponentionaly in relation to distinct traces. You have been warned. Use Heuristic miner instead.</MudAlert>
                    }
                    @if (_selectedMiner == Miner.Heuristic)
                    {
                        <MudTooltip Text="Dependency measure between two activities in one direction is expressed as a number between 0 and 1. By setting the thresholds , we specify which arcs between activities to show. Setting thresholds to 0 preserves all arcs. Values between (0,1> filters some arcs which might be mined due to noise in the log, only arcs with dependency value surpassing the threshold will be displayed. ">
                            <MudChip Variant="Variant.Text" Icon="@Icons.Outlined.Lightbulb">thresholds</MudChip>
                        </MudTooltip>
                        <MudButtonGroup Color="Color.Primary" Variant="Variant.Outlined" Size="Size.Small">
                            <MudButton OnClick="@(() => _minerSettings = new HeuristicMinerSettings())">Defaults</MudButton>
                            <MudButton OnClick="@(() => _minerSettings = new HeuristicMinerSettings { DependencyThreshold = 0, L1LThreshold = 0, L2LThreshold = 0})">All arcs</MudButton>
                        </MudButtonGroup>
                        <MudNumericField T="double" Label="Direct dependency (a ⇒ b) " HelperText="Absolute dependency threshold <0,1>" Min="0" Max="1" Step="0.05" Format="N2" HelperTextOnFocus="true"
                                         @bind-Value="_minerSettings.DependencyThreshold" For="@(() => _minerSettings.DependencyThreshold)"/>
                        <MudNumericField T="double" Label="Self loop (a ⇒ a)" HelperText="Length loop 1 dependency threshold <0,1>" Min="0" Max="1" Step="0.05" Format="N2" HelperTextOnFocus="true"
                                         @bind-Value="_minerSettings.L1LThreshold" For="@(() => _minerSettings.L1LThreshold)"/>
                        <MudNumericField T="double" Label="Loop length 2 (a ⇒ b ⇒ a)" HelperText="Length 2 loop dependency threshold <0,1>" Min="0" Max="1" Step="0.05" Format="N2" HelperTextOnFocus="true"
                                         @bind-Value="_minerSettings.L2LThreshold" For="@(() => _minerSettings.L2LThreshold)"/>
                        <br/>
                        <MudTooltip Text="Ensure each activity has at least one in and one out arcs">
                            <MudSwitch Color="Color.Primary" Label="All tasks connected"
                                       @bind-Checked="_minerSettings.AllTasksConnected" For="@(() => _minerSettings.AllTasksConnected)"/>
                        </MudTooltip>
                        @if (_minerSettings.AllTasksConnected)
                        {
                            <MudTooltip Text="Apart from the arcs exceeding Absolute dependency threshold, we also accept arcs with dependency value over threshold consisting of: best dependency value of arc coming to or from an activity, plus the relative-to-best threshold modifier">
                                <MudNumericField T="double" Label="Relative to best modifier" Min="0" Max="1" Step="0.05" Format="N2" HelperText="Relative to best threshold modifier <0,1>" HelperTextOnFocus="true"
                                                 @bind-Value="_minerSettings.RelativeToBestThreshold" For="@(() => _minerSettings.RelativeToBestThreshold)"/>
                            </MudTooltip>
                        }
                        <MudTooltip Text="Try to find long distance dependencies with indirect relation between tasks. Find pairs of tasks with similar frequencies in which the first task is directly or indirectly followed by the second one.">
                            <MudSwitch Color="Color.Primary" Label="Long distance dependencies"
                                       @bind-Checked="_minerSettings.UseLongDistance" For="@(() => _minerSettings.UseLongDistance)"/>
                        </MudTooltip>
                        @if (_minerSettings.UseLongDistance)
                        {
                            <MudTooltip>
                                <MudNumericField T="double" Label="Long distance (a {⇒}* b)" Min="0" Max="1" Step="0.05" Format="N2" HelperText="Long distance threshold <0,1>" HelperTextOnFocus="true"
                                                 @bind-Value="_minerSettings.LongDistanceThreshold" For="@(() => _minerSettings.LongDistanceThreshold)"/>
                            </MudTooltip>
                        }
                        
                    }
                    <MudSlider T="double" Value="_slider" ValueChanged="FilterLog" Min="0" Max="100" Step="0.05">traces: @_tracesVisible / @_tracesMax (dist. @_tracesDistinct)</MudSlider>
                    <br />
                    <MudButton ButtonType="ButtonType.Submit" FullWidth="true" Variant="Variant.Filled" Color="Color.Primary" Class="mt-2">Mine</MudButton>
                </EditForm>
            </MudCardContent>
        </MudCard>
        <MudCard Elevation="3" Class="mt-4">
            <MudCardContent>
                <MudSwitch Color="Color.Primary" T="bool" Label="Simplify graph"  Checked="_simplifyGraph" CheckedChanged="SimplifyChanged" />
            </MudCardContent>
        </MudCard>
        <MudExpansionPanels>
            <MudExpansionPanel Text="Transition filter" Class="mud-elevation-3 mt-4">
                <MudTable Items="_activities" Bordered="false" Dense="true" Elevation="0">
                    <HeaderContent>
                        <MudTh>activity</MudTh>
                        @if (_selectedMiner == Miner.Heuristic)
                        {<MudTh>frequency</MudTh>}
                        <MudTh>visible</MudTh>
                    </HeaderContent>
                    <RowTemplate>
                        <MudTd DataLabel="activity">@context.Key</MudTd>
                        <MudTd DataLabel="frequency">@context.Value</MudTd>
                        <MudTd DataLabel="visible">
                            <MudToggleIconButton
                                Toggled="_hiddenActivities.Contains(context.Key)"
                                ToggledChanged="() => TransitionVisibilityChanged((context.Key, !_hiddenActivities.Contains(context.Key)))"
                                Icon="@Icons.Filled.Check"
                                Color="@Color.Default"
                                Title="Shown"
                                ToggledIcon="@Icons.Filled.HideSource"
                                ToggledColor="@Color.Error"
                                ToggledTitle="Hidden"/>
                        </MudTd>
                    </RowTemplate>
                </MudTable>
            </MudExpansionPanel>
        </MudExpansionPanels>
        @if (_petriNet != null)
        {
            <MudCard Elevation="3" Class="mt-4">
                <MudCardContent>
                    <MudButton StartIcon="@Icons.Filled.Save" Variant="Variant.Outlined" Class="mb-2" OnClick="SaveModel">Save to Models</MudButton><br />
                    <MudButton StartIcon="@Icons.Filled.Download" Variant="Variant.Outlined" OnClick="DownloadPNML">PNML</MudButton>
                    <MudButton StartIcon="@Icons.Filled.Download" Variant="Variant.Outlined" OnClick="DownloadDOT">DOT</MudButton>
                </MudCardContent>
            </MudCard>
        }
    </MudItem>
    
</MudGrid>

<MudOverlay @bind-Visible="overlayActive" DarkBackground="true">
    <MudText Typo="Typo.h1">Computation in progress</MudText>
</MudOverlay>

@code {
    [Parameter]
    public string Key { get; set; }

    private string _filename;

    private bool overlayActive = false;
    private Graph _graph { get; set; } = new();
    private WorkflowLog _source_log { get; set; }
    private WorkflowLog _log { get; set; }
    private HeuristicMinerSettings _minerSettings = new();
    private Miner _selectedMiner = Miner.Heuristic;
    private PetriNet _petriNet;
    private int _tracesMax;
    private int _tracesVisible;
    private int _tracesDistinct;
    private double _slider = 100;
    private bool _simplifyGraph = true;
    private Dictionary<string, int> _activities = new();
    private HashSet<string> _hiddenActivities = new();
    private Dictionary<string, string> _changedColors = new();

    enum Miner
    {
        Alpha,
        Heuristic
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (string.IsNullOrEmpty(Key))
            {
                return;
            }
            var logFile = await EventLogStore.Get(Key);
            _filename = logFile.Metadata.Name;
            _log = _source_log = logFile.EventLog;
            _tracesMax = _tracesVisible = _log.WorkflowTraces.Count;
            await UpdateGraph();
            UpdateTraces();
        }
    }
    
    private async Task OnValidSubmit()
    {
        await UpdateGraph();
        UpdateTracesFreq();
    }

    private void FilterLog(double visiblePercentage)
    {
        _slider = visiblePercentage;
        var tracesCount = Convert.ToInt32(_tracesMax * visiblePercentage / 100) ;
        _tracesVisible = tracesCount > 0 ? tracesCount : 1;
        _log = new WorkflowLog(_source_log.WorkflowTraces.Take(_tracesVisible).ToList());
        UpdateTraces();
    }

    private async Task UpdateGraph()
    {
        overlayActive = true;
        await Task.Run(() => // async, so the component is re-rendered
        {
            var log = _log.Clone();
            WorkflowLogUtils.WorkflowLogPreprocessor(log, _hiddenActivities);
            _petriNet = _selectedMiner switch {
                Miner.Heuristic => HeuristicMiner.MinePetriNet(log, _minerSettings),
                Miner.Alpha => Alpha.MakePetriNet(new RelationMatrix(log))
                };
        });
        await _graph.RenderGraph(new GraphvizNet(_petriNet), _changedColors);
        StateHasChanged();
    }

    private void RemoveOverlay()
    {
        overlayActive = false;
        StateHasChanged();
    }

    private async Task SimplifyChanged(bool simplify)
    {
        _simplifyGraph = simplify;
        await _graph.Simplify(simplify);
    }
    
    private async Task SaveModel()
    {
        var petriNetFile = new PetriNetFile
        {
            PetriNet = _petriNet,
            Metadata = new FileMetadata()
            {
                Modified = DateTimeOffset.Now,
                Size =  System.Text.Encoding.UTF8.GetBytes(PNMLExport.Serialize(_petriNet)).Length,
                Name = _filename.Substring(0, _filename.Length - 4)
            }
        };
        await PetriNetStore.Add(petriNetFile);
    }

    private async Task DownloadPNML()
    {
        var file = System.Text.Encoding.UTF8.GetBytes(PNMLExport.Serialize(_petriNet));
        await DownloadFileService.DownloadFileAsync(_filename.Substring(0, _filename.Length - 3) + "pnml", file);
    }
    
    private async Task DownloadDOT()
    {
        var file = System.Text.Encoding.UTF8.GetBytes(DOTExport.Serialize(_petriNet));
        await DownloadFileService.DownloadFileAsync(_filename.Substring(0, _filename.Length - 3)  + "dot", file);
    }

    private void UpdateTraces()
    {
        _activities.Clear();
        int count = 0;
        var lastTrace = new List<string>();
        foreach (var trace in _log.WorkflowTraces)
        {
            if (!trace.Activities.SequenceEqual(lastTrace))
            {
                count += 1;
            }
            lastTrace = trace.Activities;
            foreach (var activity in trace.Activities.Where(a =>
                !string.IsNullOrEmpty(a) &&
                a != "<<start>>" &&
                a != "<<end>>"))
            {
                _activities[activity] = 0;
            }
        }
        _tracesDistinct = count;
        UpdateTracesFreq();
    }
    
    private void UpdateTracesFreq()
    {
        if (_petriNet != null)
        {
            foreach (var transition in _petriNet.Transitions.Where(t => !t.Invisible))
            {
                _activities[transition.Activity] = transition.Frequency;
            }
        }
        _activities.Remove("<<start>>");
        _activities.Remove("<<end>>");
        _activities.Remove("");
    }

    private void TransitionColorChanged((string, string) args)
    {
        var transitionId = args.Item1;
        var newColor = args.Item2;
        _changedColors[transitionId] = newColor;
    }

    private async Task TransitionVisibilityChanged((string, bool) args)
    {
        var activity = args.Item1;
        var hidden = args.Item2;
        if (hidden)
        {
            _hiddenActivities.Add(activity);
        }
        else
        {
            _hiddenActivities.Remove(activity);
        }
        if (_petriNet is not null)
        {
            await UpdateGraph();
        }
    }

}